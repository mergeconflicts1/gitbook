# 6.2 브랜치의 구성 및 동작

브랜치가 독립적인 개발을 보장해 준다는 것은 알았습니다. 그런데 실제 브랜치는 어떻게 구현돼 있고 어떻게 동작하는 걸까요?

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

\[그림 6-2]는 커밋 히스토리를 나타낸 그림입니다. 각 박스는 하나의 커밋을 나타내고, 가장 위 박스안에 44bde7a 문자는 커밋의 축약된 해시(SHA-1)를 나타냅니다. 그 안의 그래프는 커밋이 가리키고 있는 스냅샷을 나타냅니다.

이 그림에서 master 브랜치가 44bde7a 커밋을 가리키고 있는 것을 볼 수 있습니다. 이미 브랜치의 정의가 나와버렸네요. 그렇습니다. 브랜치는 특정 커밋을 가리키는 이름입니다.  다시말하면 브랜치는 특정 커밋에 대한 참조에 이름을 붙인 것입니다.

실제로 브랜치를 생성하면 작업 디렉토리의 파일을 변경한다거나 새로운 커밋을 만들거나 하는 특별한 작업을 하지 않습니다. 그냥 존재하는 커밋에 북마크 역할을 하는 이름을 붙이는 일을 합니다.&#x20;

브랜치는 41바이트(bytes)의 텍스트 파일로 파일 이름은 브랜치 이름과 같습니다. 41바이트 중 40바이트는 브랜치가 가리키고 있는 40자리의 커밋 해시를 저장하기 위해 사용됩니다. 나머지 1바이트는 개행문자를 저장하기 위해 사용됩니다.

이렇게 브랜치는 41바이트의 텍스트 파일에 불과하기 때문에 브랜치를 생성하는 것은 즉각적으로 수행할 수 있는 비용이 낮은 작업입니다. 그래서 Git은 다른 VCS(Version Control System)와 달리 필요에 따라 브랜치를 빠르게 생성할 수 있다는 장점이 있습니다.&#x20;

실제 브랜치의 내부가 41바이트로 구성돼 있는지는 이 장의 뒤에서 살펴보겠습니다.&#x20;

이제 현재 커밋에서 booking이라는 브랜치 하나를 생성해 보겠습니다.&#x20;

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

위 \[그림 6-3]을 보면 booking 브랜치가 생성된 것을 알 수 있습니다. 앗! 현재 커밋인 44bde7a 커밋을 가리키는 브랜치가 master와 booking 두 개가 되었습니다. 이렇게 두 개가 있으면 현재 어떤 브랜치에서 작업하는지 어떻게 알 수 있을까요?

이것은 HEAD를 통해 알 수 있습니다. HEAD는 보통 현재 활성화된 브랜치의 가장 최근 커밋을 가리키고 있습니다.그래서 HEAD를 확인하면 현재 어떤 브랜치에서 작업 중인지 알 수 있습니다.

\[그림 6-3]에서 HEAD가 master를 가리키고 있기 때문에 master가 현재 브랜치이고 여기서 브랜치를 booking로 변경(check out)하면

\


<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

\[그림 6-4] 같이 HEAD가 가리키는 브랜치가 master에서 booking로 변경됩니다. 다시말해 현재 브랜치가 booking 브랜치가 된 것이지요. 이제 실제 브랜치가 생성된 모습을 .git 폴더에 들어가 확인해 보겠습니다. 터미널 앱을 실행하고 cd 명령을 사용해 현재 Git 저장소가 있는 디렉토리로 이동합니다.

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

Git 저장소가 있는 디렉토리에서 `cd .git` 명령을 수행해 `.git` 폴더로 이동합니다. 이후 `ls -al` 명령을 사용해  디렉토리 안에 있는 파일 리스트를 확인 합니다. 파일 리스트를 확인하면 리스트에서 HEAD라는 파일을 찾을 수 가 있습니다.

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

`cat HEAD` 명령으로 현재 HEAD가 어떤 브랜치를 가리키고 있는지 확인하면 HEAD는 현재 `/refs/heads/booking`을 가리키고 있는 것을 알 수 있습니다.

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

HEAD가 가리키고 있는 `/refs/heads/booking` 파일의 확인을 위해 `cd refs/heads/` 명령을 수행해 `refs/heads` 디렉토리로 이동 합니다.&#x20;

&#x20;명령을 실행해 디렉토리 안의 파일 리스트를 확인하면 파일이름이 각각 booking, master 돼 있고, 두 파일 모두 공통적으로 크기가 41바이트 라는 것을 알 수 있습니다.

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

새로 만든 booking 브랜치의 내용을 살펴보기 위해 위 \[그림 6-8]과 같이 `cat booking` 명령을 수행합니다. 명령의 결과로 해시가 출력되는 것을 확인할 수 있습니다. 결국 브랜치의 내용은 특정 커밋의 해시임을 알 수 있습니다.

자 이제 흥미로운 일을 한번 해보죠. booking 브랜치에서 커밋을 하나 생성하면 어떻게 될까요?&#x20;

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

\[그림 6-9] 와 같이 새로운 커밋(6528e6d)을 생성하면 booking 브랜치가 새로 생성된 커밋을 가리키게 됩니다. 앞에서 브랜치는 특정 커밋을 가리키는 참조에 이름을 붙인 것이라고 했습니다. 이처럼 브랜치에서 새로운 커밋이 추가되면 브랜치는 자동으로 새로 생성된 커밋을 가리키게 됩니다.&#x20;

HEAD는 어떨까요? 앞에서 HEAD는 보통 현재 활성화된 브랜치의 가장 최근 커밋을 가리킨다고 했습니다. 새로운 커밋이 생성될 때마다 브랜치가 가리키는 커밋이 변하니 HEAD도 이에따라 변하게 됩니다. 흥미롭죠?

여기서 잠깐! 브랜치와 비슷한 기능을 하는게 태그(Tag)인 것 같은데 브랜치와 태그는 어떻게 다를까요?

브랜치와 태그 모두 특정 커밋을 가리키는 이름있는 참조로 사용되는 것은 동일합니다. 다른 점은 태그는 한번 생성되면 이후 커밋이 추가된다고 하더라도 가리키고 있는 커밋이 변하지 않습니다. 반면 브랜치는 커밋이 추가되면 가리키는 커밋이 새로운 커밋으로 변하게 됩니다. 즉, 움직이는 포인터라고 말할 수 있습니다.

지금까지 브랜치의 정의와 특징에 대해 살펴봤습니다. 이제는 브랜치 변경시 내부적으로 어떻게 동작하는지 알아보겠습니다.
